# Design Patterns

Design Patterns are a powerful tool address sub-problem generated by writing tests.

---

## Command

When there is a complex behavior to test it is possible to wrap it using a
runnable interface and call `run` only when it is requested to run the desired code.

---

## Value Object

Working with objects there is the problem of sharing references, this problem
can be solved avoiding the sharing, creating a copy or using value objects.

This last possibility can create problems of memory allocation but allows to easily
create tests. It is necessary to implement equals correctly.

---

## Null Object

When is needed an object that must be not null because it is necessary to call a
method on him, it is possible to return a Null Object if it it not set.

A Null object is an object on the desired class with the necessary method not implemented.

This allows to simplify the code and made it more readable.

---

## Template Method

When there is a invariant sequence of actions that represent a computation, it is
possible to move all the common code to a superclass and implement the specific
behavior inside a method of the sequence.

An example of this kind of sequences are:
- input/process/out
- send message/receive reply
- read command/return result

---

## Pluggable Object

There are some case when, during the computation the same if condition can be repeated
multiple times.

One solution to avoid this duplication is:
- create an interface
- put the code inside the if statements inside appropriate methods
- set in the fist if statement correct implementation of the interface
- use that implementation directly (if there is not an else the method can just be empty)

---

## Pluggable Selector

When there is an interface used to implement only one method and many subclasses,
all the implemented methods can be moved in a common class that uses a switch to
call the correct one.

In this way the same method name appears in the switch cases, in the method signature
and in the variable set at the creation. In java it is possible to use reflection to
avoid this duplication. However it is better do not abuse of this pattern and use
it only in this particular situation.

---

## Factory Method

When is needed flexibility in objects creation can be used a factory method.
This pattern allows to easily create new objects, also of different subclasses,
without calling directly the specific constructor.

---

## Imposer

When a new behavior leads to a lots of changes and complex conditional logic, then
it is a good moment to introduce a superclass and use polymorphism.

Two examples of imposers are:
- Null Object
- Composite

---

## Composite

While using a collection of objects to do some operation, sometimes,
 can be found duplication of code,
in this case can be created a interface that can be used to remove the duplication
with the help of a composite.

---

## Collecting Parameter

Sometimes when is needed to collect the result of an operation trough several objects
can be introduced, in the method performing the calculation a parameter where store the
result.

---

## Singleton

Singleton is a simple way to introduce global object without using global variables.
